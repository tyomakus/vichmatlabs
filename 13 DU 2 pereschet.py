import numpy as np

def double_shooting(f, y0, yf, t0, tf, N):
    """Решает дифференциальное уравнение с двойным пересчётом.

    Args:
        f: функция правой части дифференциального уравнения.
        y0: начальное условие.
        yf: конечное условие.
        t0: начальное значение независимой переменной.
        tf: конечное значение независимой переменной.
        N: количество шагов.

    Returns:
        y: численное решение дифференциального уравнения.
        t: массив значений независимой переменной.
    """

    # Шаг по времени
    h = (tf - t0) / N

    # Начальные условия
    y = np.zeros((N + 1, len(y0)))
    y[0, :] = y0

    # Первый пересчёт
    for i in range(N):
        y[i + 1, :] = y[i, :] + h * f(t0 + i * h, y[i, :])

    # Коррекция начального условия
    dy = yf - y[-1, :]
    y0 = y0 - dy / (1 - np.exp(-h * N))

    # Второй пересчёт
    for i in range(N):
        y[i + 1, :] = y[i, :] + h * f(t0 + i * h, y[i, :])

    # Независимая переменная
    t = np.linspace(t0, tf, N + 1)

    return y, t


# Пример: y'' = -y
def f(t, y):
    return np.array([-y[1]])

# Начальные и конечные условия
y0 = np.array([1, 0])
yf = np.array([np.cos(1), -np.sin(1)])

# Решение дифференциального уравнения
y, t = double_shooting(f, y0, yf, 0, 1, 100)

# Вывод решения
print(y)
